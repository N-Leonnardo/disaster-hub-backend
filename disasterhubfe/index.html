<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disaster Hub - Real-time Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f5f5f5;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .status-bar {
            background: #2d3748;
            color: white;
            padding: 0.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #10b981;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #map {
            flex: 1;
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 350px;
            background: white;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            z-index: 100;
            transition: transform 0.3s ease;
        }

        .sidebar.hidden {
            transform: translateX(100%);
        }

        .sidebar-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
        }

        .sidebar-header h2 {
            font-size: 1.25rem;
            color: #1f2937;
            margin-bottom: 0.5rem;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .legend {
            margin-bottom: 1.5rem;
        }

        .legend h3 {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .legend-item:hover {
            background: #f3f4f6;
        }

        .legend-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .legend-icon.incident {
            background: #ef4444;
        }

        .legend-icon.volunteer {
            background: #3b82f6;
        }

        .legend-icon.mission {
            background: #10b981;
        }

        .legend-icon.user-location {
            background: #10b981;
            border: 3px solid white;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #1f2937;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 0.25rem;
        }

        .incidents-list {
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .incidents-list h3 {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .incident-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #f9fafb;
            border-left: 3px solid #ef4444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .incident-item:hover {
            background: #f3f4f6;
            transform: translateX(4px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .incident-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .incident-item-type {
            font-weight: 600;
            color: #1f2937;
            font-size: 0.875rem;
        }

        .incident-item-status {
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 12px;
            font-weight: 500;
        }

        .incident-item-status.active {
            background: #fee2e2;
            color: #991b1b;
        }

        .incident-item-status.triaged {
            background: #fef3c7;
            color: #92400e;
        }

        .incident-item-status.resolved {
            background: #d1fae5;
            color: #065f46;
        }

        .incident-item-dispatched {
            font-size: 0.75rem;
            color: #10b981;
            font-weight: 500;
            margin-top: 0.25rem;
        }

        .incident-item-description {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .incident-item-needs {
            font-size: 0.75rem;
            color: #4b5563;
            margin-top: 0.5rem;
        }

        .incident-item-needs span {
            display: inline-block;
            background: #e0e7ff;
            color: #4338ca;
            padding: 0.125rem 0.5rem;
            border-radius: 12px;
            margin-right: 0.25rem;
            margin-top: 0.25rem;
            font-size: 0.7rem;
        }

        .activity-log {
            margin-top: 1.5rem;
        }

        .activity-log h3 {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .log-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #f9fafb;
            border-left: 3px solid #667eea;
            border-radius: 4px;
            font-size: 0.875rem;
            color: #374151;
        }

        .log-item time {
            display: block;
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 0.25rem;
        }

        .toggle-sidebar {
            position: absolute;
            top: 80px;
            right: 20px;
            background: white;
            border: none;
            padding: 0.75rem;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            z-index: 200;
            transition: transform 0.2s;
        }

        .toggle-sidebar:hover {
            transform: scale(1.1);
        }

        .toggle-sidebar svg {
            width: 20px;
            height: 20px;
        }

        .location-button {
            position: absolute;
            top: 80px;
            right: 80px;
            background: white;
            border: none;
            padding: 0.75rem;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            z-index: 200;
            transition: transform 0.2s, background 0.2s;
        }

        .location-button:hover {
            transform: scale(1.1);
            background: #f3f4f6;
        }

        .location-button.active {
            background: #3b82f6;
            color: white;
        }

        .location-button svg {
            width: 20px;
            height: 20px;
        }

        .permission-help {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 10000;
            max-width: 500px;
            display: none;
        }

        .permission-help.show {
            display: block;
        }

        .permission-help h3 {
            margin: 0 0 1rem 0;
            color: #1f2937;
            font-size: 1.25rem;
        }

        .permission-help p {
            margin: 0.5rem 0;
            color: #6b7280;
            font-size: 0.875rem;
        }

        .permission-help ol {
            margin: 1rem 0;
            padding-left: 1.5rem;
            color: #374151;
        }

        .permission-help li {
            margin: 0.5rem 0;
            font-size: 0.875rem;
        }

        .permission-help .close-btn {
            margin-top: 1.5rem;
            padding: 0.75rem 1.5rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .permission-help .close-btn:hover {
            background: #5568d3;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 9999;
            display: none;
        }

        .overlay.show {
            display: block;
        }

        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                height: 100%;
            }

            .location-button {
                right: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üó∫Ô∏è Disaster Hub - Real-time Map</h1>
        <div style="margin-top: 0.5rem;">
            <a href="create-incident.html" style="color: white; text-decoration: none; opacity: 0.9; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'; this.style.textDecoration='underline'" onmouseout="this.style.opacity='0.9'; this.style.textDecoration='none'">+ Create New Incident</a>
        </div>
    </div>
    
    <div class="status-bar">
        <div class="status-indicator">
            <div class="status-dot" id="wsStatus"></div>
            <span id="wsStatusText">Connecting...</span>
        </div>
        <div id="lastUpdate">Last update: Never</div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="permission-help" id="permissionHelp">
        <h3>üìç Enable Location Access</h3>
        <p>To show your location on the map, please enable location permissions in your browser:</p>
        <ol id="browserInstructions">
            <!-- Instructions will be inserted here based on browser -->
        </ol>
        <p style="margin-top: 1rem; font-size: 0.75rem; color: #9ca3af;">
            After enabling, click the location button again.
        </p>
        <button class="close-btn" id="closePermissionHelpBtn">Got it</button>
    </div>

    <div class="container">
        <div id="map"></div>
        <button class="location-button" id="locationButton" title="Get My Location">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
            </svg>
        </button>
        <button class="toggle-sidebar" id="toggleSidebar" title="Toggle Sidebar">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
            </svg>
        </button>
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2>Map Information</h2>
            </div>
            <div class="sidebar-content">
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="incidentCount">0</div>
                        <div class="stat-label">Incidents</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="volunteerCount">0</div>
                        <div class="stat-label">Volunteers</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="missionCount">0</div>
                        <div class="stat-label">Missions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalCount">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                </div>

                <div class="legend">
                    <h3>Legend</h3>
                    <div class="legend-item">
                        <div class="legend-icon incident"></div>
                        <span>Incidents</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-icon volunteer"></div>
                        <span>Volunteers</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-icon mission"></div>
                        <span>Missions</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-icon user-location"></div>
                        <span>Your Location</span>
                    </div>
                </div>

                <div class="incidents-list">
                    <h3>All Incidents</h3>
                    <div id="incidentsListContainer">
                        <p style="color: #6b7280; font-size: 0.875rem; padding: 0.5rem;">Loading incidents...</p>
                    </div>
                </div>

                <div class="activity-log">
                    <h3>Activity Log</h3>
                    <div id="activityLog"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB1QfE_o2BhuUebPIXRGWYmqSxzIOsuHmg&callback=initMap" async defer></script>
    
    <script>
        // Configuration
        // Backend server configuration - automatically adapts to current host
        const BACKEND_HOST = window.location.hostname;
        
        // Determine backend port:
        // - If accessed on port 80/443 (default HTTP/HTTPS), use port 3000 for API
        // - If accessed on a specific port (like 3000), use that same port
        // - If no port specified and not 80/443, default to 3000
        let BACKEND_PORT = '3000'; // Default API server port
        const currentPort = window.location.port;
        
        if (currentPort) {
            // If we're on a specific port, use it (assumes frontend and API are on same port)
            BACKEND_PORT = currentPort;
        } else {
            // No port in URL means port 80 (HTTP) or 443 (HTTPS)
            // API is on port 3000, so use that
            BACKEND_PORT = '3000';
        }
        
        const API_BASE_URL = `${window.location.protocol}//${BACKEND_HOST}:${BACKEND_PORT}`;
        // WebSocket URL - use ws:// for HTTP, wss:// for HTTPS
        const WS_PROTOCOL = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const WS_URL = `${WS_PROTOCOL}//${BACKEND_HOST}:${BACKEND_PORT}/ws`;
        
        console.log('üåê Frontend Configuration:');
        console.log('   Current URL:', window.location.href);
        console.log('   Hostname:', BACKEND_HOST);
        console.log('   Current Port:', currentPort || '(default - 80/443)');
        console.log('   API Base URL:', API_BASE_URL);
        console.log('   WebSocket URL:', WS_URL);
        console.log('   Backend Port:', BACKEND_PORT);
        
        // State
        let map;
        let markers = {
            incidents: new Map(),
            volunteers: new Map(),
            missions: new Map()
        };
        let incidentData = new Map(); // Store full incident data with markers
        let incidentInfoWindows = new Map(); // Store InfoWindows for incidents
        let missionData = new Map(); // Store mission data by mission ID
        let missionsByIncident = new Map(); // Store missions by incident ID
        let currentlyOpenInfoWindow = null; // Track the currently open InfoWindow
        let userLocationMarker = null;
        let userLocation = null;
        let ws;
        let stats = {
            incidents: 0,
            volunteers: 0,
            missions: 0
        };

        // Initialize Google Maps
        function initMap() {
            // Default center (you can change this to your preferred location)
            const defaultCenter = { lat: 40.7128, lng: -74.0060 }; // New York City
            
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 10,
                center: defaultCenter,
                mapTypeId: 'roadmap',
                styles: [
                    {
                        featureType: 'poi',
                        elementType: 'labels',
                        stylers: [{ visibility: 'off' }]
                    }
                ]
            });

            // Load initial data
            loadInitialData();
            
            // Connect WebSocket
            connectWebSocket();

            // Setup location button
            setupLocationButton();
        }

        // Load initial data from API
        async function loadInitialData() {
            try {
                // Test API connection first
                console.log(`üîó Attempting to connect to API at: ${API_BASE_URL}`);
                
                const [incidentsRes, missionsRes] = await Promise.all([
                    fetch(`${API_BASE_URL}/api/incident`),
                    fetch(`${API_BASE_URL}/api/mission`)
                ]);

                // Check if responses are ok
                if (!incidentsRes.ok) {
                    console.error(`Failed to fetch incidents: ${incidentsRes.status} ${incidentsRes.statusText}`);
                    console.error(`API URL attempted: ${API_BASE_URL}/api/incident`);
                    addActivityLog(`Failed to load incidents: ${incidentsRes.status}. Check if server is running on port ${BACKEND_PORT}`, 'error');
                } else {
                    const incidents = await incidentsRes.json();
                    if (incidents.success && incidents.data) {
                        incidents.data.forEach(incident => addIncidentMarker(incident));
                        stats.incidents = incidents.data.length;
                        console.log(`‚úÖ Loaded ${incidents.data.length} incidents`);
                        updateIncidentsList(incidents.data);
                    }
                }

                if (!missionsRes.ok) {
                    console.error(`Failed to fetch missions: ${missionsRes.status} ${missionsRes.statusText}`);
                    console.error(`API URL attempted: ${API_BASE_URL}/api/mission`);
                    addActivityLog(`Failed to load missions: ${missionsRes.status}`, 'error');
                } else {
                    const missions = await missionsRes.json();
                    if (missions.success && missions.data) {
                        missions.data.forEach(mission => {
                            // Don't add mission markers to map - missions only shown in incident InfoWindow
                            // addMissionMarker(mission);
                            missionData.set(mission._id, mission);
                            // Group missions by incident_id (check for duplicates)
                            const incidentId = String(mission.incident_id);
                            if (!missionsByIncident.has(incidentId)) {
                                missionsByIncident.set(incidentId, []);
                            }
                            // Check if mission already exists before adding
                            const existingMissions = missionsByIncident.get(incidentId);
                            const missionExists = existingMissions.some(m => m._id === mission._id);
                            if (!missionExists) {
                                missionsByIncident.get(incidentId).push(mission);
                            }
                        });
                        stats.missions = missions.data.length;
                        console.log(`‚úÖ Loaded ${missions.data.length} missions (not displayed as map markers)`);
                    }
                }

                // Volunteers will be loaded when WebSocket connects
                updateStats();
            } catch (error) {
                console.error('Error loading initial data:', error);
                console.error(`Failed to connect to: ${API_BASE_URL}`);
                addActivityLog(`Error loading initial data: ${error.message}. Make sure the server is running on ${BACKEND_HOST}:${BACKEND_PORT}`, 'error');
            }
        }

        // Fetch all volunteers from database
        async function fetchAllVolunteers() {
            try {
                console.log(`üîó Fetching volunteers from: ${API_BASE_URL}/api/volunteer`);
                const response = await fetch(`${API_BASE_URL}/api/volunteer`);
                
                if (!response.ok) {
                    console.error(`Failed to fetch volunteers: ${response.status} ${response.statusText}`);
                    console.error(`API URL attempted: ${API_BASE_URL}/api/volunteer`);
                    addActivityLog(`Failed to load volunteers: ${response.status}. Check server connection`, 'error');
                    return;
                }

                const result = await response.json();

                if (result.success && result.data) {
                    // Clear existing volunteer markers (optional - remove if you want to keep them)
                    // markers.volunteers.forEach((marker) => marker.setMap(null));
                    // markers.volunteers.clear();

                    // Add all volunteer markers
                    let addedCount = 0;
                    result.data.forEach(volunteer => {
                        const coords = getLocationCoordinates(volunteer.location);
                        if (coords) {
                            addVolunteerMarker(volunteer);
                            addedCount++;
                        }
                    });

                    stats.volunteers = result.data.length;
                    updateStats();
                    console.log(`‚úÖ Loaded ${addedCount} volunteers with valid locations`);
                    addActivityLog(`Loaded ${addedCount} volunteers from database`, 'success');
                } else {
                    console.log('‚ÑπÔ∏è No volunteers found in database');
                    addActivityLog('No volunteers found in database', 'info');
                }
            } catch (error) {
                console.error('Error fetching volunteers:', error);
                console.error(`Failed to connect to: ${API_BASE_URL}/api/volunteer`);
                addActivityLog(`Error fetching volunteers: ${error.message}`, 'error');
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            try {
                ws = new WebSocket(WS_URL);

                ws.onopen = () => {
                    updateWSStatus(true);
                    addActivityLog('WebSocket connected', 'success');
                    // Automatically get user location when connected (silent mode to reduce log noise)
                    getCurrentLocation(true);
                    // Fetch all volunteers from database
                    fetchAllVolunteers();
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateWSStatus(false);
                    addActivityLog('WebSocket error', 'error');
                };

                ws.onclose = () => {
                    updateWSStatus(false);
                    addActivityLog('WebSocket disconnected. Reconnecting...', 'warning');
                    // Reconnect after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                };
            } catch (error) {
                console.error('Error connecting WebSocket:', error);
                updateWSStatus(false);
            }
        }

        // Handle WebSocket messages
        function handleWebSocketMessage(data) {
            updateLastUpdate();
            
            switch (data.type) {
                case 'incident_created':
                    addIncidentMarker(data.data);
                    stats.incidents++;
                    addActivityLog(`New incident created: ${data.data.type || data.data._id}`, 'incident');
                    refreshIncidentsList();
                    break;
                case 'incident_updated':
                    // Update stored incident data
                    incidentData.set(data.data._id, data.data);
                    updateIncidentMarker(data.data);
                    addActivityLog(`Incident updated: ${data.data.type || data.data._id}`, 'incident');
                    refreshIncidentsList();
                    break;
                case 'incident_deleted':
                    removeIncidentMarker(data.data._id);
                    incidentData.delete(data.data._id);
                    stats.incidents--;
                    addActivityLog(`Incident deleted`, 'incident');
                    refreshIncidentsList();
                    break;
                case 'volunteer_created':
                    addVolunteerMarker(data.data);
                    stats.volunteers++;
                    addActivityLog(`New volunteer added: ${data.data.name || data.data._id}`, 'volunteer');
                    break;
                case 'volunteer_updated':
                    updateVolunteerMarker(data.data);
                    addActivityLog(`Volunteer updated: ${data.data.name || data.data._id}`, 'volunteer');
                    break;
                case 'volunteer_deleted':
                    removeVolunteerMarker(data.data._id);
                    stats.volunteers--;
                    addActivityLog(`Volunteer removed`, 'volunteer');
                    break;
                case 'mission_created':
                    // Don't add mission markers to map - missions only shown in incident InfoWindow
                    // addMissionMarker(data.data);
                    missionData.set(data.data._id, data.data);
                    // Add to missionsByIncident cache (check for duplicates)
                    const incidentId = String(data.data.incident_id);
                    if (!missionsByIncident.has(incidentId)) {
                        missionsByIncident.set(incidentId, []);
                    }
                    // Check if mission already exists before adding
                    const existingMissions = missionsByIncident.get(incidentId);
                    const missionExists = existingMissions.some(m => m._id === data.data._id);
                    if (!missionExists) {
                        missionsByIncident.get(incidentId).push(data.data);
                    }
                    stats.missions++;
                    
                    // Update incident InfoWindow if it's open to show new mission
                    const incidentInfoWindow = incidentInfoWindows.get(incidentId);
                    if (incidentInfoWindow && currentlyOpenInfoWindow === incidentInfoWindow) {
                        const incident = incidentData.get(incidentId);
                        if (incident) {
                            const missions = missionsByIncident.get(incidentId) || [];
                            incidentInfoWindow.setContent(createIncidentInfoWindowContent(incident, missions));
                        }
                    }
                    
                    addActivityLog(`New mission created: ${data.data.name || data.data._id}`, 'mission');
                    break;
                case 'mission_updated':
                    // Don't update mission markers on map - missions only shown in incident InfoWindow
                    // updateMissionMarker(data.data);
                    missionData.set(data.data._id, data.data);
                    // Update missionsByIncident cache
                    const updatedIncidentId = String(data.data.incident_id);
                    if (missionsByIncident.has(updatedIncidentId)) {
                        const missions = missionsByIncident.get(updatedIncidentId);
                        const index = missions.findIndex(m => m._id === data.data._id);
                        if (index !== -1) {
                            missions[index] = data.data;
                        }
                    }
                    
                    // Update incident InfoWindow if it's open to show updated mission
                    const updatedIncidentInfoWindow = incidentInfoWindows.get(updatedIncidentId);
                    if (updatedIncidentInfoWindow && currentlyOpenInfoWindow === updatedIncidentInfoWindow) {
                        const incident = incidentData.get(updatedIncidentId);
                        if (incident) {
                            const missions = missionsByIncident.get(updatedIncidentId) || [];
                            updatedIncidentInfoWindow.setContent(createIncidentInfoWindowContent(incident, missions));
                        }
                    }
                    
                    addActivityLog(`Mission updated: ${data.data.name || data.data._id}`, 'mission');
                    break;
                case 'mission_deleted':
                    // Don't remove mission markers from map - missions only shown in incident InfoWindow
                    // removeMissionMarker(data.data._id);
                    missionData.delete(data.data._id);
                    const deletedIncidentId = String(data.data.incident_id);
                    if (missionsByIncident.has(deletedIncidentId)) {
                        const missions = missionsByIncident.get(deletedIncidentId);
                        const index = missions.findIndex(m => m._id === data.data._id);
                        if (index !== -1) {
                            missions.splice(index, 1);
                        }
                    }
                    
                    // Update incident InfoWindow if it's open to reflect deleted mission
                    const deletedIncidentInfoWindow = incidentInfoWindows.get(deletedIncidentId);
                    if (deletedIncidentInfoWindow && currentlyOpenInfoWindow === deletedIncidentInfoWindow) {
                        const incident = incidentData.get(deletedIncidentId);
                        if (incident) {
                            const missions = missionsByIncident.get(deletedIncidentId) || [];
                            deletedIncidentInfoWindow.setContent(createIncidentInfoWindowContent(incident, missions));
                        }
                    }
                    
                    stats.missions--;
                    addActivityLog(`Mission deleted`, 'mission');
                    break;
                case 'connected':
                    addActivityLog('Connected to server', 'success');
                    break;
                case 'reload':
                    if (data.reload === true) {
                        addActivityLog('Reloading all data from backend...', 'info');
                        // Clear all existing markers and data
                        clearAllMarkers();
                        // Reload all data from backend
                        reloadAllData();
                    }
                    break;
            }
            
            updateStats();
        }

        // Helper function to extract lat/lng from location (handles both GeoJSON and lat/lng formats)
        function getLocationCoordinates(location) {
            if (!location) return null;
            
            // Handle GeoJSON format: { type: "Point", coordinates: [lng, lat] }
            if (location.type === 'Point' && Array.isArray(location.coordinates) && location.coordinates.length >= 2) {
                return {
                    lat: location.coordinates[1], // GeoJSON is [lng, lat]
                    lng: location.coordinates[0]
                };
            }
            
            // Handle lat/lng format: { lat: number, lng: number }
            if (location.lat && location.lng) {
                return {
                    lat: location.lat,
                    lng: location.lng
                };
            }
            
            return null;
        }

        // Marker management functions
        function addIncidentMarker(incident) {
            const coords = getLocationCoordinates(incident.location);
            if (!coords) {
                return; // Skip if no location data
            }

            // Store incident data
            incidentData.set(incident._id, incident);

            const marker = new google.maps.Marker({
                position: coords,
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 10,
                    fillColor: '#ef4444',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2
                },
                title: incident.type || 'Incident'
            });

            const infoWindow = new google.maps.InfoWindow({
                content: createIncidentInfoWindowContent(incident, [])
            });
            
            // Store info window
            incidentInfoWindows.set(incident._id, infoWindow);

            // Handle info window content ready event to attach button listeners
            google.maps.event.addListener(infoWindow, 'domready', () => {
                const dispatchBtn = document.getElementById(`dispatchBtn_${incident._id}`);
                if (dispatchBtn) {
                    // Remove any existing listeners
                    const newBtn = dispatchBtn.cloneNode(true);
                    dispatchBtn.parentNode.replaceChild(newBtn, dispatchBtn);
                    
                    // Add click listener
                    newBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        dispatchIncident(incident._id);
                    });
                }
            });

            marker.addListener('click', async () => {
                try {
                    // Close any currently open InfoWindow
                    if (currentlyOpenInfoWindow) {
                        currentlyOpenInfoWindow.close();
                    }
                    
                    // Update content in case incident data changed
                    const currentIncident = incidentData.get(incident._id) || incident;
                    
                    // Fetch missions for this incident
                    let missions = [];
                    try {
                        missions = await fetchMissionsForIncident(incident._id);
                    } catch (error) {
                        console.error('Error fetching missions:', error);
                        // Continue with empty missions array
                    }
                    
                    infoWindow.setContent(createIncidentInfoWindowContent(currentIncident, missions));
                    infoWindow.open(map, marker);
                    currentlyOpenInfoWindow = infoWindow;
                } catch (error) {
                    console.error('Error opening incident InfoWindow:', error);
                    // Fallback: open with basic content
                    infoWindow.setContent(createIncidentInfoWindowContent(incident, []));
                    infoWindow.open(map, marker);
                    currentlyOpenInfoWindow = infoWindow;
                }
            });

            markers.incidents.set(incident._id, marker);
        }

        // Fetch missions for a specific incident
        async function fetchMissionsForIncident(incidentId) {
            const incidentIdStr = String(incidentId);
            
            // First check cached missions
            if (missionsByIncident.has(incidentIdStr)) {
                const cachedMissions = missionsByIncident.get(incidentIdStr);
                // Remove duplicates before returning
                const uniqueMissions = Array.from(new Map(cachedMissions.map(m => [m._id, m])).values());
                return uniqueMissions;
            }
            
            // If not cached, fetch from API
            try {
                const response = await fetch(`${API_BASE_URL}/api/mission`);
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        // Clear and rebuild cache to avoid duplicates
                        const missionMap = new Map(); // Use Map to track unique missions by _id
                        
                        result.data.forEach(mission => {
                            missionData.set(mission._id, mission);
                            const id = String(mission.incident_id);
                            
                            // Use Map to ensure uniqueness
                            if (!missionMap.has(id)) {
                                missionMap.set(id, new Map());
                            }
                            // Store by mission _id to prevent duplicates
                            missionMap.get(id).set(mission._id, mission);
                        });
                        
                        // Convert Maps back to arrays and update cache
                        missionMap.forEach((missionIdMap, id) => {
                            missionsByIncident.set(id, Array.from(missionIdMap.values()));
                        });
                        
                        return missionsByIncident.get(incidentIdStr) || [];
                    }
                }
            } catch (error) {
                console.error('Error fetching missions:', error);
            }
            
            return [];
        }

        // Create incident info window content with dispatch button and missions
        function createIncidentInfoWindowContent(incident, missions = []) {
            const needsList = incident.needs && incident.needs.length > 0 
                ? incident.needs.map(need => `<li>${need}</li>`).join('')
                : '<li>None specified</li>';
            
            const dispatchedStatus = incident.dispatched ? 
                '<span style="color: #10b981; font-weight: bold;">‚úì Dispatched</span>' : 
                '<span style="color: #ef4444; font-weight: bold;">Not Dispatched</span>';
            
            const dispatchButton = !incident.dispatched ? 
                `<button id="dispatchBtn_${incident._id}" style="
                    margin-top: 10px;
                    padding: 8px 16px;
                    background: #667eea;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 600;
                    width: 100%;
                    transition: background 0.2s;
                " onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
                    Dispatch
                </button>` : 
                '<p style="margin-top: 10px; color: #10b981; font-weight: 600;">‚úì Already Dispatched</p>';

            // Build missions list (remove duplicates first)
            let missionsHtml = '';
            if (missions && missions.length > 0) {
                // Remove duplicates by mission _id
                const uniqueMissions = Array.from(
                    new Map(missions.map(mission => [mission._id, mission])).values()
                );
                
                missionsHtml = `
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e5e7eb;">
                        <p style="margin: 0 0 10px 0; font-weight: 600; color: #1f2937;"><strong>Missions (${uniqueMissions.length}):</strong></p>
                        <div style="max-height: 200px; overflow-y: auto;">
                            ${uniqueMissions.map(mission => `
                                <div style="margin-bottom: 10px; padding: 10px; background: #f9fafb; border-radius: 6px; border-left: 3px solid #667eea;">
                                    <p style="margin: 0 0 5px 0; font-weight: 600; color: #1f2937; font-size: 0.9em;">${mission.name || 'Mission'}</p>
                                    <p style="margin: 0 0 5px 0; color: #6b7280; font-size: 0.85em;">${mission.description || 'No description'}</p>
                                    <div style="display: flex; gap: 10px; font-size: 0.8em; color: #9ca3af;">
                                        <span><strong>Status:</strong> ${mission.status || 'N/A'}</span>
                                        <span><strong>Priority:</strong> ${mission.priority || 'N/A'}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else if (incident.dispatched) {
                missionsHtml = `
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e5e7eb;">
                        <p style="margin: 0; color: #9ca3af; font-size: 0.9em;">No missions created yet for this incident.</p>
                    </div>
                `;
            }

            return `
                <div style="padding: 15px; min-width: 300px; max-width: 400px; max-height: 600px; overflow-y: auto;">
                    <h3 style="margin: 0 0 15px 0; color: #1f2937; font-size: 1.2em; border-bottom: 2px solid #667eea; padding-bottom: 8px;">
                        ${incident.type || 'Incident'}
                    </h3>
                    <div style="margin-bottom: 10px;">
                        <p style="margin: 5px 0;"><strong>Status:</strong> ${incident.status || 'N/A'}</p>
                        <p style="margin: 5px 0;"><strong>Dispatched:</strong> ${dispatchedStatus}</p>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <p style="margin: 5px 0 8px 0;"><strong>Description:</strong></p>
                        <p style="margin: 0; color: #4b5563; line-height: 1.5;">${incident.description || 'No description available'}</p>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <p style="margin: 5px 0 8px 0;"><strong>Needs:</strong></p>
                        <ul style="margin: 0; padding-left: 20px; color: #4b5563;">
                            ${needsList}
                        </ul>
                    </div>
                    ${dispatchButton}
                    ${missionsHtml}
                </div>
            `;
        }

        // Dispatch an incident
        async function dispatchIncident(incidentId) {
            try {
                // Ensure ID is a string (in case it's an ObjectId object)
                const idString = String(incidentId);
                console.log(`[Dispatch] Attempting to dispatch incident: ${idString} (original type: ${typeof incidentId})`);
                const url = `${API_BASE_URL}/api/incident/${encodeURIComponent(idString)}`;
                console.log(`[Dispatch] URL: ${url}`);
                
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ dispatched: true })
                });

                console.log(`[Dispatch] Response status: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error(`[Dispatch] Error response:`, errorData);
                    throw new Error(`Failed to dispatch incident: ${response.status} ${response.statusText} - ${errorData.error || ''}`);
                }

                const result = await response.json();
                console.log(`[Dispatch] Success response:`, result);
                
                if (result.success) {
                    // Update local incident data
                    const incident = result.data;
                    incidentData.set(incidentId, incident);
                    
                    // Update the marker's info window if it exists
                    const infoWindow = incidentInfoWindows.get(incidentId);
                    if (infoWindow) {
                        // Fetch missions for updated incident
                        const missions = await fetchMissionsForIncident(incidentId);
                        infoWindow.setContent(createIncidentInfoWindowContent(incident, missions));
                    }
                    
                    addActivityLog(`Incident dispatched: ${incident?.type || incidentId}`, 'success');
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('Error dispatching incident:', error);
                addActivityLog(`Failed to dispatch incident: ${error.message}`, 'error');
            }
        }

        function addVolunteerMarker(volunteer) {
            const coords = getLocationCoordinates(volunteer.location);
            if (!coords) {
                return;
            }

            const marker = new google.maps.Marker({
                position: coords,
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 10,
                    fillColor: '#3b82f6',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2
                },
                title: volunteer.name || 'Volunteer'
            });

            const infoWindow = new google.maps.InfoWindow({
                content: `
                    <div style="padding: 10px;">
                        <h3 style="margin: 0 0 10px 0; color: #3b82f6;">${volunteer.name || 'Volunteer'}</h3>
                        <p style="margin: 5px 0;"><strong>Email:</strong> ${volunteer.email || 'N/A'}</p>
                        <p style="margin: 5px 0;"><strong>Phone:</strong> ${volunteer.phone || 'N/A'}</p>
                        <p style="margin: 5px 0;"><strong>Skills:</strong> ${volunteer.skills || 'N/A'}</p>
                    </div>
                `
            });

            marker.addListener('click', () => {
                // Close any currently open InfoWindow
                if (currentlyOpenInfoWindow) {
                    currentlyOpenInfoWindow.close();
                }
                infoWindow.open(map, marker);
                currentlyOpenInfoWindow = infoWindow;
            });

            markers.volunteers.set(volunteer._id, marker);
        }

        // Mission markers are no longer displayed on the map
        // Missions are only shown in the incident InfoWindow when clicking on an incident
        function addMissionMarker(mission) {
            // Disabled - missions are not displayed as map markers
            // They are only shown in the incident InfoWindow
            return;
        }

        function updateIncidentMarker(incident) {
            // Update stored incident data
            incidentData.set(incident._id, incident);
            
            const marker = markers.incidents.get(incident._id);
            const coords = getLocationCoordinates(incident.location);
            if (marker && coords) {
                marker.setPosition(coords);
                // Update info window content if it exists
                const infoWindow = incidentInfoWindows.get(incident._id);
                if (infoWindow) {
                    infoWindow.setContent(createIncidentInfoWindowContent(incident));
                }
            } else if (!marker && coords) {
                addIncidentMarker(incident);
            }
        }

        function updateVolunteerMarker(volunteer) {
            const marker = markers.volunteers.get(volunteer._id);
            const coords = getLocationCoordinates(volunteer.location);
            if (marker && coords) {
                marker.setPosition(coords);
            } else if (!marker && coords) {
                addVolunteerMarker(volunteer);
            }
        }

        // Mission markers are no longer displayed on the map
        function updateMissionMarker(mission) {
            // Disabled - missions are not displayed as map markers
            return;
        }

        function removeMissionMarker(id) {
            // Disabled - missions are not displayed as map markers
            return;
        }

        function removeIncidentMarker(id) {
            const marker = markers.incidents.get(id);
            if (marker) {
                marker.setMap(null);
                markers.incidents.delete(id);
            }
            incidentData.delete(id);
            incidentInfoWindows.delete(id);
        }

        function removeVolunteerMarker(id) {
            const marker = markers.volunteers.get(id);
            if (marker) {
                marker.setMap(null);
                markers.volunteers.delete(id);
            }
        }

        // Mission markers are no longer displayed on the map
        // This function is kept for compatibility but does nothing

        // Clear all markers from the map
        function clearAllMarkers() {
            console.log('[Reload] Clearing all markers...');
            
            // Clear incident markers
            markers.incidents.forEach((marker) => {
                marker.setMap(null);
            });
            markers.incidents.clear();
            incidentData.clear();
            incidentInfoWindows.clear();
            
            // Clear volunteer markers
            markers.volunteers.forEach((marker) => {
                marker.setMap(null);
            });
            markers.volunteers.clear();
            
            // Clear mission markers (if any exist)
            markers.missions.forEach((marker) => {
                marker.setMap(null);
            });
            markers.missions.clear();
            // Keep mission data for InfoWindow display, just clear markers
            // missionData.clear();
            // missionsByIncident.clear();
            
            // Close any open InfoWindow
            if (currentlyOpenInfoWindow) {
                currentlyOpenInfoWindow.close();
                currentlyOpenInfoWindow = null;
            }
            
            // Reset stats
            stats.incidents = 0;
            stats.volunteers = 0;
            stats.missions = 0;
            updateStats();
            
            console.log('[Reload] All markers cleared');
        }

        // Reload all data from backend
        async function reloadAllData() {
            try {
                console.log('[Reload] Fetching all data from backend...');
                
                // Fetch incidents, missions, and volunteers in parallel
                const [incidentsRes, missionsRes, volunteersRes] = await Promise.all([
                    fetch(`${API_BASE_URL}/api/incident`),
                    fetch(`${API_BASE_URL}/api/mission`),
                    fetch(`${API_BASE_URL}/api/volunteer`)
                ]);

                // Process incidents
                if (incidentsRes.ok) {
                    const incidents = await incidentsRes.json();
                    if (incidents.success && incidents.data) {
                        incidents.data.forEach(incident => addIncidentMarker(incident));
                        stats.incidents = incidents.data.length;
                        updateIncidentsList(incidents.data);
                        console.log(`[Reload] ‚úÖ Loaded ${incidents.data.length} incidents`);
                    }
                } else {
                    console.error(`[Reload] Failed to fetch incidents: ${incidentsRes.status}`);
                }

                // Process missions
                if (missionsRes.ok) {
                    const missions = await missionsRes.json();
                    if (missions.success && missions.data) {
                        missions.data.forEach(mission => {
                            // Don't add mission markers to map - missions only shown in incident InfoWindow
                            // addMissionMarker(mission);
                            missionData.set(mission._id, mission);
                            // Group missions by incident_id (check for duplicates)
                            const incidentId = String(mission.incident_id);
                            if (!missionsByIncident.has(incidentId)) {
                                missionsByIncident.set(incidentId, []);
                            }
                            // Check if mission already exists before adding
                            const existingMissions = missionsByIncident.get(incidentId);
                            const missionExists = existingMissions.some(m => m._id === mission._id);
                            if (!missionExists) {
                                missionsByIncident.get(incidentId).push(mission);
                            }
                        });
                        stats.missions = missions.data.length;
                        console.log(`[Reload] ‚úÖ Loaded ${missions.data.length} missions`);
                    }
                } else {
                    console.error(`[Reload] Failed to fetch missions: ${missionsRes.status}`);
                }

                // Process volunteers
                if (volunteersRes.ok) {
                    const volunteers = await volunteersRes.json();
                    if (volunteers.success && volunteers.data) {
                        let addedCount = 0;
                        volunteers.data.forEach(volunteer => {
                            const coords = getLocationCoordinates(volunteer.location);
                            if (coords) {
                                addVolunteerMarker(volunteer);
                                addedCount++;
                            }
                        });
                        stats.volunteers = volunteers.data.length;
                        console.log(`[Reload] ‚úÖ Loaded ${addedCount} volunteers`);
                    }
                } else {
                    console.error(`[Reload] Failed to fetch volunteers: ${volunteersRes.status}`);
                }

                updateStats();
                addActivityLog('All data reloaded from backend', 'success');
                console.log('[Reload] ‚úÖ All data reloaded successfully');
            } catch (error) {
                console.error('[Reload] Error reloading data:', error);
                addActivityLog(`Error reloading data: ${error.message}`, 'error');
            }
        }

        // UI update functions
        function updateStats() {
            document.getElementById('incidentCount').textContent = stats.incidents;
            document.getElementById('volunteerCount').textContent = stats.volunteers;
            document.getElementById('missionCount').textContent = stats.missions;
            document.getElementById('totalCount').textContent = stats.incidents + stats.volunteers + stats.missions;
        }

        // Update incidents list in sidebar
        function updateIncidentsList(incidents) {
            const container = document.getElementById('incidentsListContainer');
            
            if (!incidents || incidents.length === 0) {
                container.innerHTML = '<p style="color: #6b7280; font-size: 0.875rem; padding: 0.5rem;">No incidents found</p>';
                return;
            }

            container.innerHTML = incidents.map(incident => {
                const coords = getLocationCoordinates(incident.location);
                const statusClass = incident.status ? incident.status.toLowerCase() : 'active';
                const needsList = incident.needs && incident.needs.length > 0 
                    ? incident.needs.map(need => `<span>${need}</span>`).join('')
                    : '<span style="color: #9ca3af;">None specified</span>';
                
                return `
                    <div class="incident-item" onclick="navigateToIncident('${incident._id}')" title="Click to navigate to this incident">
                        <div class="incident-item-header">
                            <div class="incident-item-type">${incident.type || 'Incident'}</div>
                            <div class="incident-item-status ${statusClass}">${incident.status || 'Active'}</div>
                        </div>
                        ${incident.dispatched ? '<div class="incident-item-dispatched">‚úì Dispatched</div>' : ''}
                        <div class="incident-item-description">${incident.description || 'No description'}</div>
                        ${incident.needs && incident.needs.length > 0 ? `<div class="incident-item-needs">${needsList}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // Refresh incidents list from stored data
        async function refreshIncidentsList() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/incident`);
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        updateIncidentsList(result.data);
                    }
                }
            } catch (error) {
                console.error('Error refreshing incidents list:', error);
            }
        }

        // Navigate to incident location on map (global function for onclick)
        window.navigateToIncident = function(incidentId) {
            const incident = incidentData.get(incidentId);
            if (!incident) {
                // Try to get from API if not in local data
                fetch(`${API_BASE_URL}/api/incident/${incidentId}`)
                    .then(res => res.json())
                    .then(result => {
                        if (result.success && result.data) {
                            goToIncidentLocation(result.data);
                        } else {
                            addActivityLog('Incident not found', 'error');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching incident:', error);
                        addActivityLog('Failed to load incident', 'error');
                    });
                return;
            }
            
            goToIncidentLocation(incident);
        }

        // Navigate map to incident location
        async function goToIncidentLocation(incident) {
            const coords = getLocationCoordinates(incident.location);
            if (!coords) {
                addActivityLog('Incident location not available', 'error');
                return;
            }

            // Close any currently open InfoWindow
            if (currentlyOpenInfoWindow) {
                currentlyOpenInfoWindow.close();
            }

            // Center map on incident location
            map.setCenter(coords);
            map.setZoom(15);

            // Open info window for the incident
            const marker = markers.incidents.get(incident._id);
            if (marker) {
                const infoWindow = incidentInfoWindows.get(incident._id);
                if (infoWindow) {
                    // Fetch missions for this incident
                    const missions = await fetchMissionsForIncident(incident._id);
                    infoWindow.setContent(createIncidentInfoWindowContent(incident, missions));
                    infoWindow.open(map, marker);
                    currentlyOpenInfoWindow = infoWindow;
                    
                    // Set up dispatch button if needed
                    google.maps.event.addListener(infoWindow, 'domready', () => {
                        const dispatchBtn = document.getElementById(`dispatchBtn_${incident._id}`);
                        if (dispatchBtn) {
                            const newBtn = dispatchBtn.cloneNode(true);
                            dispatchBtn.parentNode.replaceChild(newBtn, dispatchBtn);
                            newBtn.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                dispatchIncident(incident._id);
                            });
                        }
                    });
                }
            }

            addActivityLog(`Navigated to: ${incident.type || 'Incident'}`, 'info');
        };

        function updateWSStatus(connected) {
            const statusDot = document.getElementById('wsStatus');
            const statusText = document.getElementById('wsStatusText');
            
            if (connected) {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
            }
        }

        function updateLastUpdate() {
            const now = new Date();
            document.getElementById('lastUpdate').textContent = 
                `Last update: ${now.toLocaleTimeString()}`;
        }

        function addActivityLog(message, type = 'info') {
            const logContainer = document.getElementById('activityLog');
            const logItem = document.createElement('div');
            logItem.className = 'log-item';
            
            const now = new Date();
            logItem.innerHTML = `
                <div>${message}</div>
                <time>${now.toLocaleTimeString()}</time>
            `;
            
            logContainer.insertBefore(logItem, logContainer.firstChild);
            
            // Keep only last 20 log items
            while (logContainer.children.length > 20) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Location functions
        function setupLocationButton() {
            const locationButton = document.getElementById('locationButton');
            
            locationButton.addEventListener('click', () => {
                getCurrentLocation();
            });
        }

        function getCurrentLocation(silent = false) {
            if (!navigator.geolocation) {
                if (!silent) {
                    addActivityLog('Geolocation is not supported by your browser', 'error');
                }
                return;
            }

            const locationButton = document.getElementById('locationButton');
            if (locationButton) {
                locationButton.disabled = true;
                locationButton.style.opacity = '0.6';
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    userLocation = { lat, lng };

                    // Center map on user location
                    map.setCenter(userLocation);
                    map.setZoom(15);

                    // Add or update user location marker
                    if (userLocationMarker) {
                        userLocationMarker.setPosition(userLocation);
                    } else {
                        userLocationMarker = new google.maps.Marker({
                            position: userLocation,
                            map: map,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 12,
                                fillColor: '#10b981',
                                fillOpacity: 1,
                                strokeColor: '#ffffff',
                                strokeWeight: 3
                            },
                            title: 'Your Location',
                            zIndex: 1000 // Make sure it's on top
                        });

                        // Add pulsing circle around user location
                        const circle = new google.maps.Circle({
                            strokeColor: '#10b981',
                            strokeOpacity: 0.3,
                            strokeWeight: 2,
                            fillColor: '#10b981',
                            fillOpacity: 0.1,
                            map: map,
                            center: userLocation,
                            radius: 100 // 100 meters
                        });

                        const infoWindow = new google.maps.InfoWindow({
                            content: `
                                <div style="padding: 10px;">
                                    <h3 style="margin: 0 0 10px 0; color: #10b981;">üìç Your Location</h3>
                                    <p style="margin: 5px 0;"><strong>Latitude:</strong> ${lat.toFixed(6)}</p>
                                    <p style="margin: 5px 0;"><strong>Longitude:</strong> ${lng.toFixed(6)}</p>
                                </div>
                            `
                        });

                        userLocationMarker.addListener('click', () => {
                            infoWindow.open(map, userLocationMarker);
                        });
                    }

                    if (locationButton) {
                        locationButton.classList.add('active');
                        locationButton.disabled = false;
                        locationButton.style.opacity = '1';
                    }
                    if (!silent) {
                        addActivityLog('Location found and map centered', 'success');
                    }
                },
                (error) => {
                    let errorMessage = '';
                    let helpMessage = '';
                    
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = 'Location permission denied';
                            helpMessage = 'Click the lock icon in your browser\'s address bar and allow location access, or check your browser settings.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = 'Location information unavailable';
                            helpMessage = 'Your device cannot determine your location. Check GPS/WiFi settings.';
                            break;
                        case error.TIMEOUT:
                            errorMessage = 'Location request timed out';
                            helpMessage = 'Please try again. Make sure GPS is enabled on your device.';
                            break;
                        default:
                            errorMessage = 'Unknown error occurred';
                            helpMessage = 'Please try again or check your browser settings.';
                            break;
                    }
                    
                    if (!silent) {
                        addActivityLog(errorMessage, 'error');
                        if (helpMessage) {
                            // Show a more detailed message in console
                            console.error('üìç Location Error:', errorMessage);
                            console.info('üí° Help:', helpMessage);
                            
                            // Show browser-specific instructions
                            showLocationPermissionHelp(error.code === error.PERMISSION_DENIED);
                        }
                    }
                    
                    if (locationButton) {
                        locationButton.disabled = false;
                        locationButton.style.opacity = '1';
                        // Remove active state if permission denied
                        if (error.code === error.PERMISSION_DENIED) {
                            locationButton.classList.remove('active');
                        }
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        // Show location permission help
        function showLocationPermissionHelp(isPermissionDenied) {
            if (!isPermissionDenied) return;
            
            const helpDiv = document.getElementById('permissionHelp');
            const overlay = document.getElementById('overlay');
            const instructions = document.getElementById('browserInstructions');
            
            // Detect browser and show appropriate instructions
            const userAgent = navigator.userAgent.toLowerCase();
            let browserInstructions = '';
            
            if (userAgent.includes('chrome') || userAgent.includes('chromium')) {
                browserInstructions = `
                    <li>Look for the <strong>lock icon</strong> or <strong>location icon</strong> in the address bar (left side)</li>
                    <li>Click on it to open site settings</li>
                    <li>Change "Location" from "Block" to "Allow"</li>
                    <li>Refresh the page and try again</li>
                `;
            } else if (userAgent.includes('firefox')) {
                browserInstructions = `
                    <li>Look for the <strong>lock icon</strong> or <strong>shield icon</strong> in the address bar</li>
                    <li>Click on it and select "More Information"</li>
                    <li>Go to the "Permissions" tab</li>
                    <li>Find "Access your location" and change it to "Allow"</li>
                    <li>Refresh the page and try again</li>
                `;
            } else if (userAgent.includes('safari')) {
                browserInstructions = `
                    <li>Go to <strong>Safari ‚Üí Settings ‚Üí Websites ‚Üí Location Services</strong></li>
                    <li>Find this website in the list</li>
                    <li>Change it from "Deny" to "Allow"</li>
                    <li>Or click the <strong>location icon</strong> in the address bar and select "Allow"</li>
                    <li>Refresh the page and try again</li>
                `;
            } else if (userAgent.includes('edge')) {
                browserInstructions = `
                    <li>Look for the <strong>lock icon</strong> in the address bar</li>
                    <li>Click on it to open site permissions</li>
                    <li>Find "Location" and change it to "Allow"</li>
                    <li>Refresh the page and try again</li>
                `;
            } else {
                browserInstructions = `
                    <li>Look for a <strong>lock icon</strong> or <strong>location icon</strong> in your browser's address bar</li>
                    <li>Click on it to access site settings</li>
                    <li>Find location/permissions settings and allow access</li>
                    <li>Refresh the page and try again</li>
                `;
            }
            
            instructions.innerHTML = browserInstructions;
            helpDiv.classList.add('show');
            overlay.classList.add('show');
        }

        // Close permission help
        function closePermissionHelp() {
            const helpDiv = document.getElementById('permissionHelp');
            const overlay = document.getElementById('overlay');
            if (helpDiv) helpDiv.classList.remove('show');
            if (overlay) overlay.classList.remove('show');
        }

        // Set up close button and overlay click handlers (run after DOM is ready)
        setTimeout(() => {
            const closeBtn = document.getElementById('closePermissionHelpBtn');
            const overlay = document.getElementById('overlay');
            
            if (closeBtn) {
                closeBtn.addEventListener('click', closePermissionHelp);
            }
            if (overlay) {
                overlay.addEventListener('click', closePermissionHelp);
            }
        }, 100);

        // Sidebar toggle
        document.getElementById('toggleSidebar').addEventListener('click', () => {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('hidden');
        });

        // Make initMap available globally for Google Maps callback
        window.initMap = initMap;
    </script>
</body>
</html>
